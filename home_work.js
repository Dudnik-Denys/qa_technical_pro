console.log('number' + 3 + 3)
// Коли відбувається конкатенація стрінги з числом отримуємо стрінгу, тому number33

console.log(null + 3)
// Коли додаємо або віднімаємо від null, то null рахується за 0, а 0 + 3 = 3

console.log(5 && "qwerty")
// В данному випадку перше значення не може бути оцінене як false у порівнянні, тому отримуємо друге значення

console.log(+'40' + +'2' + "hillel");
// Отримуємо 42hillel бо якщо перед стрінгою поставити знак, то вона конвертується в число

console.log('10' - 5 === 6);
// отримуємо false бо це твердження не є вірним

console.log(true + false)
// Отримуємо 1 бо true та false відносяться до 1 та 0 відповідно

console.log('4px' - 3)
// Отримуємо NaN бо відняти число від стрінги значення якої не складається тільки з цифр неможливо і щоб не впасти з помилкою
// js повертає нам NaN

console.log('4' - 3)
// отримуємо 1 бо у стрінгу тільки числове значення і воно конвертується на число в такому випадку

console.log('6' + 3 ** 0);
// Отримуємо стрінгове значення 61 бо поперше зберігається посліовність математичних дій, тобто першим відбудеться піднесення до ступеню,
// а потім вже додавання. Будь-яке число в 0-му ступені це 1, до стрінгового 6 додаємо 1 і він теж стає стрінгою, тобто додаємо стрінги і
// тому 61

console.log(12 / '6')
// Отримуємо 2 в цьому випадку бо якщо як і у випадку с + символ математичної дії знаходиться перед стрінгою, то вона конвертується в
// число. Правда мені як людині яка звикла до python в такому випадку незвично бачити ціле число 

console.log('10' + (5 === 6));
// Спочатку виконується умова в дужках та поертається її результат, а саме false, бо 5 не дорівнє 6, а потім до стрінги 10 додається
// false і він конвертується за такої умови теж у стрінгу, тому отримуємо 10false
// null == ''

console.log(3 ** (9 / 3));
// Тут просто послідовність математичних дій, спочатку дія в дужке 9 / 3, а потім піднесення до 3 у ступінь що є результатом дії у
// дужках, тобто 3 ** 3

console.log(!!'false' == !!'true')
// Якщо б тут не було знаків оклику, то це б не було true, бо це дві різні стрінги, але після юзання знаків оклику, що означать "не"
// ці стрінги приводяться до булевих значень (атк як вони не пусті то до true), а подвійне юзання це є заперечення, тобто "не" "не",
// тобто тут відбувається порівняння "не не true" == "не не true" 

console.log(0 || '0' && 1)
// Тут отримуємо 1 бо перша умова не виконується

console.log((+null == false) < 1);
// Тут ми отрумуємо false бо перед null є знак + і в цьому випадку він розглядається як число тобто 0 і відповідно дорівнює false бо
// нуль дорівнює нулю як не дивно, тобто це правильно і в дужках отримуємо true, а true це 1, а 1 не менше ніж 1

console.log(false && true || true)
// також false && true це не true, тому тут виконується логічне або

console.log(false && (false || true));
// спочатку виконується дія у дужках, тобто порівняння false або true і отрумуємо true, а за умови false і true ми отруємо false бо
// тільки одне значення true

console.log((+null == false) < 1 ** 5);
// Тут таке саме пояснення як і для прикладу вище, логіка не змінється, лише додається дія зведення до ступіню
